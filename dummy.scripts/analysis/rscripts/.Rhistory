# trees <- inputs$trees
states <- inputs$states
karyotypes <- inputs$karyotypes
# make a new column to prepare data to make the likelihood function in
# diversitree
dat.new$Karyotype <- paste(dat.new$chroms, dat.new$scs, sep = "")
dat.new$Karyotype.states <- NA
# fill in the states names
for(j in 1:nrow(dat.new)){
dat.new$Karyotype.states[j] <- which(karyotypes %in% dat.new$Karyotype[j])
}
# make a vector which includes states names and species names
MuSSE.states <- dat.new$Karyotype.states
names(MuSSE.states) <- dat.new$SpeciesName
# make the likelihood function
lik <- make.musse(tree = phy,
states = MuSSE.states,
strict = F,
k = length(karyotypes),
control = list(method = "ode"))
# constrain the likelihood function
con.lik <- constrainQmat(qmat = qmat, lik = lik)
# run a temp mcmc to get a value to w
temp <-  mcmc(con.lik,
x.init = rep(1,length(argnames(con.lik))),
nsteps = 20,
w = 1,
prior = prior,
upper = 10)
w <- diff(sapply(temp[11:20, 2:(length(argnames(con.lik))+1)], quantile, c(.05, .95)))
# run the mcmc
results[[i]] <- mcmc(con.lik,
x.init = rep(1,length(argnames(con.lik))),
nsteps = nsim,
w = w,
prior = prior,
upper = 10)
results[[i]][2:(length(argnames(con.lik))+1)] <- results[[i]][2:(length(argnames(con.lik))+1)] / tree.depth
}
# pad determines how many digits there are in the states. for example if there
# are 100 states then fist state will be written as 001 instead of just 1.
# this is done because diversitree adds the zero digits in front of the states
# depending in the number of states
if (ncol(qmat) < 100)
constrainQmat <-  function (qmat, lik) {
# pad determines how many digits there are in the states. for example if there
# are 100 states then fist state will be written as 001 instead of just 1.
# this is done because diversitree adds the zero digits in front of the states
# depending in the number of states
if (ncol(qmat) < 100)
pad <- 2
if (ncol(qmat) >= 100)
pad <- 3
if (ncol(qmat) < 10)
pad <- 1
# lets store the input qmatrix in a new object called parMat
parMat <- qmat
# rename the colnames and row names of the parMat to numerals.
colnames(parMat) <- sprintf(paste("%0", pad, "d", sep = ""), 1:ncol(parMat))
rownames(parMat) <- colnames(parMat)
# make a new table which have three columns. col 1 and col 2 have the state
# names.
rate.table <- as.data.frame(matrix(, nrow(parMat) * ncol(parMat),3))
rate.table[, 1] <- rep(as.character(row.names(parMat)), each = ncol(parMat))
rate.table[, 2] <- rep(as.character(colnames(parMat)), nrow(parMat))
rate.table[, 3] <- as.character(c(t(parMat)))
rate.table <- rate.table[rate.table[, 1] != rate.table[2],]
## here is a description of the different parameters that will be used in the
## qmatrix
# r1 = 1,    # AA fusion  XO
# r2 = 2,    # AA fission XO
# r3 = 3,    # AA fusion  XY
# r4 = 4,    # AA fission XY
# r5 = 5,    # AA fusion  Neo.XY
# r6 = 6,    # AA fission Neo.XY
# r7 = 7,    # AA fusion  XXY
# r8 = 8,    # AA fission XXY
# r9 = 9,    # AA fusion  XYY
# r10 = 10,  # AA fission XYY
# r11 = 11,  # SA fusion  XO -> XY
# r12 = 12,  # SA fusion  XY -> Neo.XY
# r13 = 13,  # SA fusion  XY -> XXY
# r14 = 14,  # SA fusion  XY -> XYY
# r15 = 15,  # transision Neo.XY -> XY
# r16 = 16,  # X fission  XY -> XXY
# r17 = 17,  # Y fission  XY -> XYY
# r18 = 18,  # Y loss     XY -> XO
# r19 = 19,  # Y loss     XYY -> XY
# r20 = 20,  # X fusion   XXY -> XY
# r21 = 21,  # Y capture  XO -> XY
# r22 = 22,  # polyploidy XO
# r23 = 23,  # polyploidy XY
# r24 = 24,  # polyploidy Neo.XY
# r25 = 25,  # polyploidy XXY
# r26 = 26,  # polyploidy XYY
# r27 = 27,  # translocation XO -> XXY (White(1973), Animal cytology and evolution)
# now fill the third column of the rate table. this will define which parameters
# we will use to constrain the initial likelihood function
rate.table[rate.table[, 3] == 1, 3] <- "par01"
rate.table[rate.table[, 3] == 2, 3] <- "par02"
rate.table[rate.table[, 3] == 3, 3] <- "par03"
rate.table[rate.table[, 3] == 4, 3] <- "par04"
rate.table[rate.table[, 3] == 5, 3] <- "par05"
rate.table[rate.table[, 3] == 6, 3] <- "par06"
rate.table[rate.table[, 3] == 7, 3] <- "par07"
rate.table[rate.table[, 3] == 8, 3] <- "par08"
rate.table[rate.table[, 3] == 9, 3] <- "par09"
rate.table[rate.table[, 3] == 10, 3] <- "par10"
rate.table[rate.table[, 3] == 11, 3] <- "parq1"
rate.table[rate.table[, 3] == 12, 3] <- "par12"
rate.table[rate.table[, 3] == 13, 3] <- "par13"
rate.table[rate.table[, 3] == 14, 3] <- "par14"
rate.table[rate.table[, 3] == 15, 3] <- "par15"
rate.table[rate.table[, 3] == 16, 3] <- "par16"
rate.table[rate.table[, 3] == 17, 3] <- "par17"
rate.table[rate.table[, 3] == 18, 3] <- "par18"
rate.table[rate.table[, 3] == 19, 3] <- "par19"
rate.table[rate.table[, 3] == 20, 3] <- "par20"
rate.table[rate.table[, 3] == 21, 3] <- "par21"
rate.table[rate.table[, 3] == 22, 3] <- "par22"
rate.table[rate.table[, 3] == 23, 3] <- "par23"
rate.table[rate.table[, 3] == 24, 3] <- "par24"
rate.table[rate.table[, 3] == 25, 3] <- "par25"
rate.table[rate.table[, 3] == 26, 3] <- "par26"
rate.table[rate.table[, 3] == 27, 3] <- "par27"
formulae <- vector(mode = "character", length = nrow(rate.table))
for (i in 1:nrow(rate.table)) {
formulae[i] <- paste("q",
rate.table[i, 1],
rate.table[i,2],
" ~ ",
rate.table[i, 3],
collapse = "",
sep = "")
lambda <- mu <- vector()
for(i in 1:ncol(parMat)){
lambda <- c(lambda, paste("lambda", colnames(parMat)[i],
" ~ lambda1", sep = ""))
mu <- c(mu, paste("mu", colnames(parMat)[i],
" ~ mu1", sep = ""))
}
}
extras <- c("par01",
"par02",
"par03",
"par04",
"par05",
"par06",
"par07",
"par08",
"par09",
"par10",
"par11",
"par12",
"par13",
"par14",
"par15",
"par16",
"par17",
"par18",
"par19",
"par20",
"par21",
"par22",
"par23",
"par24",
"par25",
"par26",
"par27",
"lambda1",
"mu1")
lik.con <- constrain(lik, formulae = c(formulae, lambda, mu), extra = extras)
colnames(parMat) <- rownames(parMat) <- colnames(qmat)
return(lik.con)
}
# load libraries
library(phytools)
library(chromePlus)
library(evobiR)
# library(coda)
library(diversitree)
library(viridis)
# load helper functions
source("helper.functions.R")
# define the number of simulations that will be performed
nsim <- 100
prior <- make.prior.exponential(r = .5)
# make a place holder for results
results <- vector(mode = "list", length = 100)
i <- 1
# get data
dat <- GetData(trees = "../data/Trees/posterior.trees.nex",
data = "../data/chrom.data/chroms.csv")
# read in trees
tree <- read.nexus("../data/Trees/posterior.trees.nex")[[i]]
# lets try this to Orthoptera
dat <- dat[dat$order == "Orthoptera",]
# rename some of the scs for clarity'=
dat$SCS[dat$notes == "X1X1X2X2/X1X2Y1"] <- "XXY"
dat$SCS[dat$notes == "X1X1/X1Y1Y2"] <- "XYY"
dat$SCS[dat$notes == "X1X1X2X2/X1X2Y"] <- "XXY"
dat$SCS[dat$SCS == "XY|homomorphic"] <- "XY"
# isolate those data that we need
dat <- dat[dat$SCS %in% c("XO", "XY", "XXY", "XYY"),]
# remove species that have no chromosome number data
dat <- dat[!(is.na(dat$haploid)),]
# get the haploid chromosome number value
dat$hap.auto[dat$SCS == "XO"] <- dat$haploid[dat$SCS == "XO"] - 1
dat$hap.auto[dat$SCS == "XY"] <- dat$haploid[dat$SCS == "XY"] - 1
dat$hap.auto[dat$SCS == "XXY"] <- dat$haploid[dat$SCS == "XXY"] - 2
dat$hap.auto[dat$SCS == "XYY"] <- dat$haploid[dat$SCS == "XYY"] - 1
# keep these tips only
phy <- keep.tip(tree, dat$species)
# make tree unit length
tree.depth <-  max(branching.times(phy))
phy$edge.length <- phy$edge.length / tree.depth
# make a data table to hold the species names, chromosome number and
# sex chromosome system
dat.new <-  as.data.frame(matrix(data=NA, nrow = Ntip(phy), ncol = 3))
colnames(dat.new) <- c("SpeciesName", "chroms", "scs")
# fill in the data table
dat.new$SpeciesName <- dat$species
dat.new$chroms <- dat$hap.auto
dat.new$scs <- dat$SCS
# now we get the qmatrix and pmatrix
inputs <- get.matrixes.v2(haploid.scs = T,
autosome.as.input = T,
Neo.sex = F,
complex = T,
chrom.range.expansion = 0,
dat = dat.new,
trees = phy,
def.rates = list(r01 = 1,  # r1 = 1,    # AA fusion  XO
r02 = 2,  # r2 = 2,    # AA fission XO
r03 = 1,  # r3 = 3,    # AA fusion  XY
r04 = 2,  # r4 = 4,    # AA fission XY
r05 = 1,  # r5 = 5,    # AA fusion  Neo.XY
r06 = 2,  # r6 = 6,    # AA fission Neo.XY
r07 = 1,  # r7 = 7,    # AA fusion  XXY
r08 = 2,  # r8 = 8,    # AA fission XXY
r09 = 1,  # r9 = 9,    # AA fusion  XYY
r10 = 2,  # r10 = 10,  # AA fission XYY
r11 = 3,  # r11 = 11,  # SA fusion  XO -> XY
r12 = 3,  # r12 = 12,  # SA fusion  XY -> Neo.XY
r13 = 3,  # r13 = 13,  # SA fusion  XY -> XXY
r14 = 3,  # r14 = 14,  # SA fusion  XY -> XYY
r15 = 4,  # r15 = 15,  # transision Neo.XY -> XY
r16 = 5,  # r16 = 16,  # X fission  XY -> XXY
r17 = 6,  # r17 = 17,  # Y fission  XY -> XYY
r18 = 7,  # r18 = 18,  # Y loss     XY -> XO
r19 = 8,  # r19 = 19,  # Y loss     XYY -> XY
r20 = 9,  # r20 = 20,  # X fusion   XXY -> XY
r21 = 10,  # r21 = 21,  # Y capture  XO -> XY
r22 = 0,  # r22 = 22,  # polyploidy XO
r23 = 0,  # r23 = 23,  # polyploidy XY
r24 = 0,  # r24 = 24,  # polyploidy Neo.XY
r25 = 0,  # r25 = 25,  # polyploidy XXY
r26 = 0,  # r26 = 26,  # polyploidy XYY
r27 = 0)) # r27 = 27,  # translocation XO -> XXY (White(1973), Animal cytology and evolution)
View(get.matrixes.v2)
# load libraries
library(phytools)
library(chromePlus)
library(evobiR)
# library(coda)
library(diversitree)
library(viridis)
# load helper functions
source("helper.functions.R")
# define the number of simulations that will be performed
nsim <- 100
prior <- make.prior.exponential(r = .5)
# make a place holder for results
results <- vector(mode = "list", length = 100)
i <- 1
# get data
dat <- GetData(trees = "../data/Trees/posterior.trees.nex",
data = "../data/chrom.data/chroms.csv")
# read in trees
tree <- read.nexus("../data/Trees/posterior.trees.nex")[[i]]
# lets try this to Orthoptera
dat <- dat[dat$order == "Orthoptera",]
# rename some of the scs for clarity'=
dat$SCS[dat$notes == "X1X1X2X2/X1X2Y1"] <- "XXY"
dat$SCS[dat$notes == "X1X1/X1Y1Y2"] <- "XYY"
dat$SCS[dat$notes == "X1X1X2X2/X1X2Y"] <- "XXY"
dat$SCS[dat$SCS == "XY|homomorphic"] <- "XY"
# isolate those data that we need
dat <- dat[dat$SCS %in% c("XO", "XY", "XXY", "XYY"),]
# remove species that have no chromosome number data
dat <- dat[!(is.na(dat$haploid)),]
# get the haploid chromosome number value
dat$hap.auto[dat$SCS == "XO"] <- dat$haploid[dat$SCS == "XO"] - 1
dat$hap.auto[dat$SCS == "XY"] <- dat$haploid[dat$SCS == "XY"] - 1
dat$hap.auto[dat$SCS == "XXY"] <- dat$haploid[dat$SCS == "XXY"] - 2
dat$hap.auto[dat$SCS == "XYY"] <- dat$haploid[dat$SCS == "XYY"] - 1
# keep these tips only
phy <- keep.tip(tree, dat$species)
# make tree unit length
tree.depth <-  max(branching.times(phy))
phy$edge.length <- phy$edge.length / tree.depth
# make a data table to hold the species names, chromosome number and
# sex chromosome system
dat.new <-  as.data.frame(matrix(data=NA, nrow = Ntip(phy), ncol = 3))
colnames(dat.new) <- c("SpeciesName", "chroms", "scs")
# fill in the data table
dat.new$SpeciesName <- dat$species
dat.new$chroms <- dat$hap.auto
dat.new$scs <- dat$SCS
# now we get the qmatrix and pmatrix
inputs <- get.matrixes(haploid.scs = T,
autosome.as.input = T,
Neo.sex = F,
complex = T,
chrom.range.expansion = 0,
dat = dat.new,
trees = phy,
def.rates = list(r01 = 1,  # r1 = 1,    # AA fusion  XO
r02 = 2,  # r2 = 2,    # AA fission XO
r03 = 1,  # r3 = 3,    # AA fusion  XY
r04 = 2,  # r4 = 4,    # AA fission XY
r05 = 1,  # r5 = 5,    # AA fusion  Neo.XY
r06 = 2,  # r6 = 6,    # AA fission Neo.XY
r07 = 1,  # r7 = 7,    # AA fusion  XXY
r08 = 2,  # r8 = 8,    # AA fission XXY
r09 = 1,  # r9 = 9,    # AA fusion  XYY
r10 = 2,  # r10 = 10,  # AA fission XYY
r11 = 3,  # r11 = 11,  # SA fusion  XO -> XY
r12 = 3,  # r12 = 12,  # SA fusion  XY -> Neo.XY
r13 = 3,  # r13 = 13,  # SA fusion  XY -> XXY
r14 = 3,  # r14 = 14,  # SA fusion  XY -> XYY
r15 = 4,  # r15 = 15,  # transision Neo.XY -> XY
r16 = 5,  # r16 = 16,  # X fission  XY -> XXY
r17 = 6,  # r17 = 17,  # Y fission  XY -> XYY
r18 = 7,  # r18 = 18,  # Y loss     XY -> XO
r19 = 8,  # r19 = 19,  # Y loss     XYY -> XY
r20 = 9,  # r20 = 20,  # X fusion   XXY -> XY
r21 = 10,  # r21 = 21,  # Y capture  XO -> XY
r22 = 0,  # r22 = 22,  # polyploidy XO
r23 = 0,  # r23 = 23,  # polyploidy XY
r24 = 0,  # r24 = 24,  # polyploidy Neo.XY
r25 = 0,  # r25 = 25,  # polyploidy XXY
r26 = 0,  # r26 = 26,  # polyploidy XYY
r27 = 0)) # r27 = 27,  # translocation XO -> XXY (White(1973), Animal cytology and evolution)
# get the relavent inputs
qmat <- inputs$qmat
pmat <- inputs$pmat
# trees <- inputs$trees
states <- inputs$states
karyotypes <- inputs$karyotypes
states
# make a new column to prepare data to make the likelihood function in
# diversitree
dat.new$Karyotype <- paste(dat.new$chroms, dat.new$scs, sep = "")
dat.new$Karyotype.states <- NA
# fill in the states names
for(j in 1:nrow(dat.new)){
dat.new$Karyotype.states[j] <- which(karyotypes %in% dat.new$Karyotype[j])
}
# make a vector which includes states names and species names
MuSSE.states <- dat.new$Karyotype.states
names(MuSSE.states) <- dat.new$SpeciesName
# make the likelihood function
lik <- make.musse(tree = phy,
states = MuSSE.states,
strict = F,
k = length(karyotypes),
control = list(method = "ode"))
# constrain the likelihood function
con.lik <- constrainQmat(qmat = qmat, lik = lik)
argnames(con.lik)
# run a temp mcmc to get a value to w
temp <-  mcmc(con.lik,
x.init = rep(1,length(argnames(con.lik))),
nsteps = 20,
w = 1,
prior = prior,
upper = 10)
mcmc(con.lik,
x.init = rep(1,length(argnames(con.lik))),
nsteps = 20,
w = 1,
)
# run a temp mcmc to get a value to w
temp <-  mcmc(con.lik,
x.init = rep(1,length(argnames(con.lik))),
nsteps = 20,
w = 1,
prior = prior,
upper = 20)
w <- diff(sapply(temp[11:20, 2:(length(argnames(con.lik))+1)], quantile, c(.05, .95)))
# run the mcmc
results[[i]] <- mcmc(con.lik,
x.init = rep(1,length(argnames(con.lik))),
nsteps = nsim,
w = w,
prior = prior,
upper = 10)
results[[i]][2:(length(argnames(con.lik))+1)] <- results[[i]][2:(length(argnames(con.lik))+1)] / tree.depth
plot(results[[1]]$p)
plot(results[[1]]$p, type = "l")
# run the mcmc
results[[i]] <- mcmc(con.lik,
x.init = rep(1,length(argnames(con.lik))),
nsteps = 1000,
w = w,
prior = prior,
upper = 10)
results[[i]][2:(length(argnames(con.lik))+1)] <- results[[i]][2:(length(argnames(con.lik))+1)] / tree.depth
plot(results[[1]]$p, type = "l")
post.burnin <- results[[i]][501:1000,]
View(post.burnin)
colnames(post.burnin)
qmat == 1
colnames(post.burnin)
qmat[qmat == 1] <- mean(post.burnin$par01)
View(qmat)
qmat[qmat == 2] <- mean(post.burnin$par02)
qmat[qmat == 3] <- mean(post.burnin$par03)
qmat[qmat == 5] <- mean(post.burnin$par05)
qmat[qmat == 7] <- mean(post.burnin$par07)
qmat[qmat == 9] <- mean(post.burnin$par09)
qmat[qmat == 10] <- mean(post.burnin$par10)
?make.simmap
hists <- make.simmap(tree = phy,
x = pmat,
model = qmat,
nsim = nsim,
pi = "estimated",
Q = qmat)
# run the mcmc
results[[i]] <- mcmc(con.lik,
x.init = rep(1,length(argnames(con.lik))),
nsteps = 100,
w = w,
prior = prior,
upper = 10)
post.burnin <- results[[i]][51:100,]
colnames(post.burnin)
qmat[qmat == 1] <- mean(post.burnin$par01)
qmat[qmat == 2] <- mean(post.burnin$par02)
qmat[qmat == 3] <- mean(post.burnin$par03)
qmat[qmat == 5] <- mean(post.burnin$par05)
qmat[qmat == 7] <- mean(post.burnin$par07)
qmat[qmat == 9] <- mean(post.burnin$par09)
qmat[qmat == 10] <- mean(post.burnin$par10)
hists <- make.simmap(tree = phy,
x = pmat,
model = qmat,
nsim = nsim,
pi = "estimated",
Q = qmat)
View(post.burnin)
View(qmat)
mean(post.burnin$par01)
mean(post.burnin$par03)
mean(post.burnin$par02)
# get the relavent inputs
qmat <- inputs$qmat
qmat[qmat == 1] <- mean(post.burnin$par01)
qmat[qmat == 2] <- mean(post.burnin$par02)
qmat[qmat == 3] <- mean(post.burnin$par03)
qmat[qmat == 5] <- mean(post.burnin$par05)
qmat[qmat == 7] <- mean(post.burnin$par07)
qmat[qmat == 9] <- mean(post.burnin$par09)
qmat[qmat == 10] <- mean(post.burnin$par10)
hists <- make.simmap(tree = phy,
x = pmat,
model = qmat,
nsim = nsim,
pi = "estimated",
Q = qmat)
hists <- make.simmap(tree = phy,
x = pmat,
model = qmat,
nsim = 1,
pi = "estimated",
Q = qmat)
hists <- make.simmap(tree = phy,
x = pmat,
nsim = 1,
pi = "estimated",
Q = qmat)
results[[i]][2:(length(argnames(con.lik))+1)] <- results[[i]][2:(length(argnames(con.lik))+1)] / tree.depth
phy$edge.length
phy$edge.length <- phy$edge.length * tree.depth
post.burnin
phy$edge.length
max(branching.times(phy))
# get the relavent inputs
qmat <- inputs$qmat
post.burnin <- results[[i]][51:100,]
colnames(post.burnin)
qmat[qmat == 1] <- mean(post.burnin$par01)
qmat[qmat == 2] <- mean(post.burnin$par02)
qmat[qmat == 3] <- mean(post.burnin$par03)
qmat[qmat == 5] <- mean(post.burnin$par05)
qmat[qmat == 7] <- mean(post.burnin$par07)
qmat[qmat == 9] <- mean(post.burnin$par09)
qmat[qmat == 10] <- mean(post.burnin$par10)
hists <- make.simmap(tree = phy,
x = pmat,
nsim = 1,
pi = "estimated",
Q = qmat)
phy
qmat
hists <- make.simmap(tree = phy,
x = pmat,
nsim = 1,
pi = "equal",
Q = qmat)
