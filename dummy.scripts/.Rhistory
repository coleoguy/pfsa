for(i in ((nrow(qmat)/devider)+1):((nrow(qmat)/devider)*2)){
qmat[i,(((nrow(qmat)/devider)) + i-1)] <- 3
}
}
# Y chromosome loss in XY
for(i in ((nrow(qmat)/devider)+1):((nrow(qmat)/devider)*2)){
qmat[i, i-(nrow(qmat)/devider)] <- 4
}
# Y chromosome loss in multi-xy
if(complex == T){
for(i in (((nrow(qmat)/devider)*2)+1):(nrow(qmat))){
qmat[i, i-(nrow(qmat)/devider)] <- 88
}
}
hp <- ncol(qmat)/devider + 1
if(complex == T){
drops <- c(1:(minChroms-2), hp:(hp + minChroms-3),(hp*2 - 1):((hp*2 - 1) + minChroms-3))
}else{
drops <- c(1:(minChroms-2), hp:(hp + minChroms-3))
}
qmat <- qmat[-drops, -drops]
return(qmat)
}
qmatGen <- function(chrom.range = NULL, complex = F){
# define total number of chromosome states
#chrom.range <- c(5, 10)
maxChroms <- chrom.range[2] + 1
minChroms <- chrom.range[1] - 1
if(complex == T){
nChroms <- (maxChroms - 1) * 3
}else{
nChroms <- (maxChroms - 1) * 2
}
# make the initial q matrix
qmat <- matrix(data = 0,
nrow = nChroms,
ncol = nChroms)
# define rownames and colnames
# although row names and col names starts from 1, chromsome counts starts from
# 2
if(complex == T){
row.names(qmat)  <- colnames(qmat) <- c(paste(2:maxChroms,"XO",sep=""),
paste(2:maxChroms,"XY",sep=""),
paste(2:maxChroms,"XXY/XYY",sep=""))
}else{
row.names(qmat)  <- colnames(qmat) <- c(paste(2:maxChroms,"XO",sep=""),
paste(2:maxChroms,"XY",sep=""))
}
# following are the rate parameters that we define
# rate1 <- autosomal fusions in XO and XY sex chromosome sytems
# rate2 <- autosomal fissions in XO anf XY sex chromosome systems
# rate3 <- sex chromosome autosome fusions
# rate4 <- Y chromosome loss
if(complex == T){
devider <- 3
}else{
devider <- 2
}
# autosomal fissions and fusions in XO systems
for(i in 1){
while (i < (nrow(qmat)/devider)) {
qmat[i, i+1] <- 1 # fissions
qmat[i+1, i] <- 2 # fusions
i <- i + 1
}
}
# autosomal fissions and fusions in XY systems
for(i in ((nrow(qmat)/devider)+1):((nrow(qmat)/devider)*2)){
if(i < ((nrow(qmat)/devider)*2)){
qmat[i, i+1] <- 1 # fissions
qmat[i+1, i] <- 2 # fusions
}
}
# autosomal fissions and fusions in complex systems
for(i in (((nrow(qmat)/devider)*2)+1):nrow(qmat)){
if(i < nrow(qmat)){
qmat[i, i+1] <- 1 # fissions
qmat[i+1, i] <- 2 # fusions
}
}
# sex chromosome autosome fusion from XO to XY
for(i in 2:(nrow(qmat)/devider)){
qmat[i,(nrow(qmat)/devider) + i -1] <- 3
}
# sex chromosome autosome fusion from XY to multi-XY
if(complex == T){
for(i in ((nrow(qmat)/devider)+1):((nrow(qmat)/devider)*2)){
qmat[i,(((nrow(qmat)/devider)) + i-1)] <- 3
}
}
# Y chromosome loss in XY
for(i in ((nrow(qmat)/devider)+1):((nrow(qmat)/devider)*2)){
qmat[i, i-(nrow(qmat)/devider)] <- 4
}
# Y chromosome loss in multi-xy
if(complex == T){
for(i in (((nrow(qmat)/devider)*2)+1):(nrow(qmat))){
qmat[i, i-(nrow(qmat)/devider)] <- 88
}
}
hp <- ncol(qmat)/devider + 1
if(complex == T){
drops <- c(1:(minChroms-2), hp:(hp + minChroms-3),(hp*2 - 1):((hp*2 - 1) + minChroms-3))
}else{
drops <- c(1:(minChroms-2), hp:(hp + minChroms-3))
}
qmat <- qmat[-drops, -drops]
return(qmat)
}
chrom.range <- c(5, 10)
qmatGen(complex = T)
qmatGen(chrom.range <- c(5, 10),complex = T)
qmat <- qmatGen(chrom.range <- c(5, 10),complex = T)
qmat <- qmatGen(chrom.range <- c(5, 10),complex = F)
qmat <- qmatGen(chrom.range <- c(5, 10),complex = T)
qmatGen <- function(chrom.range = NULL){
# define total number of chromosome states
#chrom.range <- c(10, 19)
maxChroms <- chrom.range[2] + 1
minChroms <- chrom.range[1] - 1
nChroms <- (maxChroms - 1) * 2
# make the initial q matrix
qmat <- matrix(data = 0,
nrow = nChroms,
ncol = nChroms)
# define rownames and colnames
# although row names and col names starts from 1, chromsome counts starts from
# 2
row.names(qmat)  <- colnames(qmat) <- c(paste(2:maxChroms,"XO",sep=""),
paste(2:maxChroms,"XY",sep=""))
# following are the rate parameters that we define
# rate1 <- autosomal fusions in XO and XY sex chromosome sytems
# rate2 <- autosomal fissions in XO anf XY sex chromosome systems
# rate3 <- sex chromosome autosome fusions
# rate4 <- Y chromosome loss
# autosomal fissions and fusions in XO systems
for(i in 1){
while (i < (nrow(qmat)/2)) {
qmat[i, i+1] <- 1 # fissions
qmat[i+1, i] <- 2 # fusions
i <- i + 1
}
}
# autosomal fissions and fusions in XY systems
for(i in ((nrow(qmat)/2)+1):nrow(qmat)){
if(i < nrow(qmat)){
qmat[i, i+1] <- 1 # fissions
qmat[i+1, i] <- 2 # fusions
}
}
# sex chromosome autosome fusion
for(i in 2:(nrow(qmat)/2)){
qmat[i,(nrow(qmat)/2) + i -1] <- 3
}
# Y chromosome loss
for(i in ((nrow(qmat)/2)+1):nrow(qmat)){
qmat[i, i-(nrow(qmat)/2)] <- 4
}
if(chrom.range[1] > 2){
}
hp <- ncol(qmat)/2 + 1
drops <- c(1:(minChroms-2), hp:(hp + minChroms-3))
qmat <- qmat[-drops, -drops]
return(qmat)
}
qmat <- qmatGen(chrom.range <- c(5, 10))
# load libraries
library(phytools)
library(chromePlus)
library(evobiR)
library(coda)
library(diversitree)
library(viridis)
# load helper functions
source("helper.functions.R")
nsim <- 10
# simulate a single tree with n number of tips
tree <- tree.bd(pars=c(3,1), max.taxa=150)
tree$edge.length <- tree$edge.length/max(branching.times(tree))
# simulate a single tree with n number of tips
tree <- tree.bd(pars=c(3,1), max.taxa=150)
tree$edge.length <- tree$edge.length/max(branching.times(tree))
# simulate a trait dataset
trait <-  simChrom(tree, pars=c(2, 1, 2, 1, 0, 0, 0, 0, .2,  .2, 20, 0),
limits = c(10, 30), model = "ChromPlus")
# lets make sure we have enough transitions from 1 sex chromosome system
# to the other
while (sum(trait$binary.state) < 3) {
trait <-  simChrom(tree, pars=c(.3, .6, .3, .6, 0, 0, 0, 0, .2,  .3, 20, 1),
limits = c(10, 30), model = "ChromPlus")
}
# look at the trait distributution
trait$binary.state
trait$chrom.num
# make a data table to hold the species names, chromosome number and
# sex chromosome system
dat <-  as.data.frame(matrix(data=NA, nrow = Ntip(tree), ncol = 3))
colnames(dat) <- c("SpecisName", "chroms", "scs")
# fill in the data table
dat$SpecisName <- tree$tip.label
dat$chroms <- trait$chrom.num
dat$scs <- c("XO", "XY")[trait$binary.state + 1]
# now we get the qmatrix and pmatrix
inputs <- get.matrixes(chrom.range = range(dat$chroms),
Haplodiploidy = T,
Neo.sex = F,
complex = F,
chrom.range.expansion = 1,
dat = dat,
trees = tree)
# get the relavent inputs
qmat <- inputs$qmat
pmat <- inputs$pmat
dat <- inputs$dat
trees <- inputs$trees
states <- inputs$states
# perform stochastic mappings
colnames(pmat) <- colnames(qmat) <-
row.names(qmat) <- states$karyotype
hists <- make.simmap(tree = trees,
x = pmat,
model = qmat,
nsim = nsim,
pi = "estimated")
# lets look at a randtom stochastic map
# add colors
plot(hists[[sample(1:nsim, 1)]])
# lets look at a randtom stochastic map
# add colors
setNames(object = viridis(ncol(pmat)),nm = colnames(pmat))
# lets look at a randtom stochastic map
# add colors
cols <- setNames(object = viridis(ncol(pmat)),nm = colnames(pmat))
plot(hists[[sample(1:nsim, 1)]], col = cols)
describe.simmap(hists)$count
# get the number of times each transision has occured
counts <- describe.simmap(hists)$count
# get colnames that represent SA and AA fusions
SAfusionColnames <- vector(mode = "character", length = nrow(qmat))
AAfusionColnames <- vector(mode = "character", length = nrow(qmat))
for(i in 1:nrow(qmat)){
if(length(which(qmat[i,] == 3)) != 0){
SAfusionColnames[i] <- paste(i,",",which(qmat[i,] == 3),sep = "")
}
if(length(which(qmat[i,] == 2)) != 0){
AAfusionColnames[i] <- paste(i,",",which(qmat[i,] == 2),sep = "")
}
}
SAfusionColnames
AAfusionColnames
# remove those that are empty
SAfusionColnames <- SAfusionColnames[SAfusionColnames != ""]
AAfusionColnames <- AAfusionColnames[AAfusionColnames != ""]
# get the col number that represent each fusion type
SAfusionCol <- which(colnames(counts) %in% SAfusionColnames)
AAfusionCol <- which(colnames(counts) %in% AAfusionColnames)
# get the number of times each fusion has occured
SAfusioncounts <- rowSums(counts[, c(SAfusionCol)])
AAfusioncounts <- rowSums(counts[, c(AAfusionCol)])
# get the observed pfSA
obspropSA <- SAfusioncounts/AAfusioncounts
# remove entries that are either inf or NaN
obspropSA <- obspropSA[!(is.infinite(obspropSA) | is.nan(obspropSA))]
# now we get the expected pfsa
# make a table to hold the pfsa given scs and chrom number
pfSA.tab <- as.data.frame(matrix(data = NA, nrow = nrow(states), ncol = 2))
colnames(pfSA.tab) <- c("state", "pfsa")
for(i in 1:nrow(states)){
# for XO / ZO
if(gsub(pattern = "[0-9]",x= states$karyotype[i], replacement = "") %in% c("XO", "ZO")){
pfSA.tab$state[i] <- states$sim.state[i]
pfSA.tab$pfsa[i] <- Pfsa(Da = as.numeric(gsub(pattern = "[A-z]",
x= states$karyotype[i] ,
replacement = "")),
scs = "XO")
}
# for XY / ZW
if(gsub(pattern = "[0-9]",x= states$karyotype[i], replacement = "") %in% c("XY", "ZW")){
pfSA.tab$state[i] <- states$sim.state[i]
pfSA.tab$pfsa[i] <- Pfsa(Da = as.numeric(gsub(pattern = "[A-z]",
x= states$karyotype[i] ,
replacement = "")),
scs = "XY")
}
# for Neo.XY / Neo.ZW
if(gsub(pattern = "[0-9]",x= states$karyotype[i], replacement = "") %in% c("Neo.XY", "Neo.ZW")){
pfSA.tab$state[i] <- states$sim.state[i]
pfSA.tab$pfsa[i] <- Pfsa(Da = as.numeric(gsub(pattern = "[A-z]",
x= states$karyotype[i] ,
replacement = "")),
scs = "XY")
}
# for XXY, XYY / ZZW, ZWW
if(gsub(pattern = ".*/",x= states$karyotype[i], replacement = "") %in% c("XXY", "XYY", "ZWW", "ZZW")){
pfSA.tab$state[i] <- states$sim.state[i]
pfSA.tab$pfsa[i] <- Pfsa(Da = as.numeric(gsub(pattern = "[A-z./]",
x= states$karyotype[i] ,
replacement = "")),
scs = "XXY")
}
}
# get the expeveted pSA
expSA <- c()
for(i in 1:nsim){
times <- describe.simmap(hists[[i]])$times[2, -(nrow(states)+1)]
expSA[i] <- sum(times * pfSA.tab$pfsa)
}
# lets plot
# clear any previous plots
dev.off()
plot(density(expSA, bw = .009),
xlim = c(-0.5, 1.5),
ylim = c(-2,40),
main = "",
xlab = "Proportion sex-autosome fusion",
cex.axis = 1, cex.lab = 1)
polygon(density(expSA, bw = .009),
col = rgb(1, 0, 0, .3))
lines(density(obspropSA))
polygon(density(obspropSA),
col = rgb(0, 0, 1, .3))
points(x = c(1, 1),
y = c(40, 38),
pch = 15,
col = c(rgb(1, 0, 0, .5),
rgb(0, 0, 1, .5)),
cex = 1.5)
text(x = c(1, 1),
y = c(40, 38),
labels = c("Expected", "Inferred"),
pos = 4,cex = .8)
mean(obspropSA)
HPDobsPsa <- HPDinterval(as.mcmc(obspropSA))
HPDexpPsa <- HPDinterval(as.mcmc(expSA))
# plot the HPD intervals
segments(x0 = HPDexpPsa[,1],
x1 = HPDexpPsa[,2],
y0 = -1,
y1 = -1,
col = rgb(1, 0, 0, .5),
lwd = 3)
segments(x0 = HPDobsPsa[,1],
x1 = HPDobsPsa[,2],
y0 = -2,
y1 = -2,
col = rgb(0, 0, 1, .5),
lwd = 3)
def.rates <- list()
def.rates$r1
is.null(def.rates$r1)
# define rate parameters
if(is.null(def.rates$r1)){
def.rates$r1 <- 1
}
if(is.null(def.rates$r2)){
def.rates$r2 <- 2
}
if(is.null(def.rates$r3)){
def.rates$r3 <- 3
}
if(is.null(def.rates$r4)){
def.rates$r4 <- 4
}
if(is.null(def.rates$r5)){
def.rates$r5 <- 5
}
if(is.null(def.rates$r6)){
def.rates$r6 <- 6
}
if(is.null(def.rates$r7)){
def.rates$r7 <- 7
}
if(is.null(def.rates$r8)){
def.rates$r8 <- 8
}
if(is.null(def.rates$r9)){
def.rates$r9 <- 9
}
if(is.null(def.rates$r10)){
def.rates$r10 <- 10
}
if(is.null(def.rates$r11)){
def.rates$r11 <- 11
}
if(is.null(def.rates$r12)){
def.rates$r12 <- 12
}
if(is.null(def.rates$r13)){
def.rates$r13 <- 13
}
View(def.rates)
maxChroms <- 5
## devider ##
# this is the parameter that defines the number of parts in the qmatrix.
# we have  4 parts on our q matrix.
# a part for XO / ZO
# a part for XY / ZW
# a part for Neo.XY / Neo.ZW
# a part for complex XY / complex ZW
devider <- 5
nChroms <- (maxChroms -1) * devider
# here we will make the complete q matrix wichi will include all 4 parts and
# depending on the imput data we will remove those parts that are not needed
# make the initial q matrix
qmat <- matrix(data = 0,
nrow = nChroms,
ncol = nChroms)
row.names(qmat)  <- colnames(qmat) <- c(paste(2:maxChroms,"XO",sep=""),
paste(2:maxChroms,"XY",sep=""),
paste(2:maxChroms,"Neo.XY",sep=""),
paste(2:maxChroms,"XXY",sep=""),
paste(2:maxChroms,"XYY",sep=""))
# here we define the number of rows and columns assign for each scs
limiter <- (nrow(qmat)/devider)
# autosomal fissions and fusions in XO systems
for(i in 1){
while (i < limiter) {
qmat[i, i+1] <- def.rates$r1 # fissions
qmat[i+1, i] <- def.rates$r2 # fusions
i <- i + 1
}
}
# autosomal fissions and fusions in XY systems
for(i in ((limiter+1):(limiter*2))){
if(i < (limiter*2)){
qmat[i, i+1] <- def.rates$r1 # fissions
qmat[i+1, i] <- def.rates$r2 # fusions
}
}
# autosomal fisions and fusions in Neo.XY systems
for(i in ((limiter*2)+1):(limiter*3)){
if(i < (limiter*3)){
qmat[i, i+1] <- def.rates$r1 # fissions
qmat[i+1, i] <- def.rates$r2 # fusions
}
}
# autosomal fissions and fusions in XXY systems
for(i in ((limiter*3)+1):(limiter*4)){
if(i < (limiter*4)){
qmat[i, i+1] <- def.rates$r1 # fissions
qmat[i+1, i] <- def.rates$r2 # fusions
}
}
# autosomal fissions and fusions in XYY systems
for(i in ((limiter*4)+1):(limiter*5)){
if(i < (limiter*5)){
qmat[i, i+1] <- def.rates$r1 # fissions
qmat[i+1, i] <- def.rates$r2 # fusions
}
}
# sex chromosome autosome fusion from XO to XY
for(i in 2:limiter){
qmat[i,limiter + i -1] <- def.rates$r3
}
# sex chromosome autosome fusion from XY to Neo-XY
for(i in (limiter + 1):(limiter*2)){
if(((limiter)+i-1) == limiter*2){
qmat[i,((limiter)+i-1)] <- 0
}else{
qmat[i,((limiter)+i-1)] <- def.rates$r4
}
}
# transision back to XY from Neo-XY
for(i in (limiter*2 + 1):(limiter*3)){
qmat[i,(i-limiter)] <- def.rates$r5
}
# sex chromosome autosome fusion from XY to XXY
for(i in (limiter + 1):(limiter*2)){
if(((limiter*2)+(i)-1) == limiter*3){
qmat[i,((limiter*2)+i-1)] <- 0
}else{
qmat[i,((limiter*2)+i-1)] <- def.rates$r6
}
}
# sex chromosome autosome fusion from XY to XYY
for(i in (limiter + 1):(limiter*2)){
if(((limiter*3)+(i)-1) == limiter*4){
qmat[i,((limiter*3)+i-1)] <- 0
}else{
qmat[i,((limiter*3)+i-1)] <- def.rates$r7
}
}
# sex chromosome fissoin from XY to complex-XY
for(i in (limiter + 1):(limiter*2)){
qmat[i,((limiter*2)+i)] <- def.rates$r8
}
# sex chromosome fissoin from XY to complex-XY
for(i in (limiter + 1):(limiter*2)){
qmat[i,((limiter*3)+i)] <- def.rates$r9
}
# y chromosome loss in XY systems
for(i in (limiter + 1):(limiter*2)){
qmat[i,(i-limiter)] <- def.rates$r10
}
# sex chromosome loss in complex systems (transision back to XY)
for(i in (limiter*3 + 1):(limiter*4)){
qmat[i,(i-limiter*2)] <- def.rates$r11
}
for(i in (limiter*4 + 1):(limiter*5)){
qmat[i,(i-limiter*3)] <- def.rates$r12
}
# transition from XO to XY through capture
for(i in 2:limiter){
qmat[i,limiter + i] <- def.rates$r13
}
#
View(qmat)
# transition from XO to XY through capture
for(i in 1:limiter){
qmat[i,limiter + i] <- def.rates$r13
}
View(qmat)
